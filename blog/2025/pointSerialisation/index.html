<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h2 id="1-why-serialization-matters">1. Why serialization matters</h2> <p>Traditional point cloud models like <strong>PointTransformerV1</strong> or <strong>PointNet++</strong> operate on <strong>unordered sets</strong> of points.</p> <p>To define local neighborhoods, they rely on:</p> <ul> <li>FPS (Farthest Point Sampling),</li> <li>KNN (K-Nearest Neighbors),</li> <li>or Grid/Voxel pooling.</li> </ul> <p>Those operations create small groups (patches) of points, shaped like <code class="language-plaintext highlighter-rouge">[N, K, C]</code>, where:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">N</code> = number of center points,</li> <li> <code class="language-plaintext highlighter-rouge">K</code> = number of neighbors,</li> <li> <code class="language-plaintext highlighter-rouge">C</code> = number of features.</li> </ul> <p>But in <strong>PointTransformerV3</strong> or <strong>PointMamba</strong>, this paradigm shifts:</p> <blockquote> <p>The entire point cloud becomes a single ordered <strong>sequence</strong> <code class="language-plaintext highlighter-rouge">[L, C]</code>.</p> </blockquote> <p>So we need a <strong>consistent way to order points in 3D</strong>.<br> That’s what <strong>serialization</strong> does.</p> <hr> <h2 id="2-the-z-order-morton-order-curve">2. The Z-order (Morton order) curve</h2> <p>We can’t directly sort 3D coordinates <code class="language-plaintext highlighter-rouge">(x, y, z)</code> — it’s not one-dimensional.<br> But we can <strong>map</strong> each 3D point to a <strong>single integer key</strong> that roughly preserves spatial proximity.</p> <p>This mapping is called the <strong>Morton code</strong> or <strong>Z-order</strong>.</p> <h3 id="example-in-2d-for-visualization">Example in 2D (for visualization)</h3> <p>Below is a Z-order traversal of a 4×4 grid (2 bits per axis):</p> <figure> <picture> <img src="/assets/img/pointTransformerV3/z_order.png" class="img-fluid rounded z-depth-1 shadow-sm" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>In this curve:</p> <ul> <li>Each cell <code class="language-plaintext highlighter-rouge">(x, y)</code> is assigned a <strong>Z-shaped index</strong>.</li> <li>Cells that are close in space get <strong>close indices</strong>.</li> <li>When we sort points by this index, we obtain a <strong>spatially coherent sequence</strong>.</li> </ul> <hr> <h2 id="3-bit-interleaving-explained">3. Bit interleaving explained</h2> <p>Let’s take 3D integer coordinates <code class="language-plaintext highlighter-rouge">x, y, z</code> in binary.</p> <p>Suppose:</p> <ul> <li><code class="language-plaintext highlighter-rouge">x = 5 → 101₂</code></li> <li><code class="language-plaintext highlighter-rouge">y = 3 → 011₂</code></li> <li><code class="language-plaintext highlighter-rouge">z = 2 → 010₂</code></li> </ul> <p>Each number has 3 bits: <code class="language-plaintext highlighter-rouge">x₂x₁x₀</code>, <code class="language-plaintext highlighter-rouge">y₂y₁y₀</code>, <code class="language-plaintext highlighter-rouge">z₂z₁z₀</code>.</p> <p>The <strong>Morton encoding</strong> takes these bits and <strong>interleaves them</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Morton(x,y,z) = z2 y2 x2  z1 y1 x1  z0 y0 x0

</code></pre></div></div> <p>Then you interpret this as a single binary number.</p> <table> <thead> <tr> <th>Bit group</th> <th>z</th> <th>y</th> <th>x</th> <th>Resulting value</th> </tr> </thead> <tbody> <tr> <td>2</td> <td>0</td> <td>0</td> <td>1</td> <td>(001)</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> <td>0</td> <td>(110)</td> </tr> <tr> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>(011)</td> </tr> </tbody> </table> <p>Concatenating them → <code class="language-plaintext highlighter-rouge">001110011₂ = 115</code> (decimal).<br> So the point <code class="language-plaintext highlighter-rouge">(x=5,y=3,z=2)</code> gets key <code class="language-plaintext highlighter-rouge">115</code>.</p> <p>Two nearby points will have binary patterns that differ in only a few low bits,<br> so their Morton keys are numerically close → <strong>locality is preserved</strong>.</p> <hr> <h2 id="4-handling-multiple-batches">4. Handling multiple batches</h2> <p>In training, we often have <strong>multiple point clouds</strong> in the same batch.<br> If we serialize them all, their Morton keys could <strong>collide</strong> (same value).</p> <p>To prevent this, PointTransformerV3 reserves <strong>different numeric intervals</strong> for each batch.</p> <h3 id="example">Example</h3> <p>Let’s say:</p> <ul> <li>Batch 0 → keys range <code class="language-plaintext highlighter-rouge">[0, 2⁴⁸ - 1]</code> </li> <li>Batch 1 → keys range <code class="language-plaintext highlighter-rouge">[2⁴⁸, 2×2⁴⁸ - 1]</code> </li> <li>Batch 2 → keys range <code class="language-plaintext highlighter-rouge">[2×2⁴⁸, 3×2⁴⁸ - 1]</code> </li> </ul> <p>This is done by <strong>embedding the batch ID</strong> into the highest bits:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
global_key = (batch_id &lt;&lt; 48) | morton_key

</code></pre></div></div> <p>So the final 64-bit key looks like this:</p> <table> <thead> <tr> <th>Bits</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>[63:48]</td> <td>Batch ID</td> </tr> <tr> <td>[47:0]</td> <td>Morton-encoded position</td> </tr> </tbody> </table> <p>Now, when you sort all points in the dataset together,<br> each batch occupies a <strong>separate contiguous interval</strong>, so there is no interference.</p> <hr> <h2 id="5-putting-it-all-together">5. Putting it all together</h2> <h3 id="step-1-discretize-the-coordinates">Step 1. Discretize the coordinates</h3> <p>To use Morton encoding, we convert floating coordinates <code class="language-plaintext highlighter-rouge">(x, y, z)</code><br> into <strong>integer voxel coordinates</strong>:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">grid_coord</span> <span class="o">=</span> <span class="nf">floor</span><span class="p">((</span><span class="n">coord</span> <span class="o">-</span> <span class="n">coord</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">grid_size</span><span class="p">)</span>
</code></pre></div></div> <p>This ensures the cloud fits into an integer cube, e.g. <code class="language-plaintext highlighter-rouge">[0..255]^3</code>.</p> <hr> <h3 id="step-2-compute-morton-keys">Step 2. Compute Morton keys</h3> <p>Using the <strong>bit interleaving</strong> method:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">morton_encode</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
        <span class="n">bit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
        <span class="n">key</span> <span class="o">|=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> \
             <span class="o">|</span> <span class="p">((</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> \
             <span class="o">|</span> <span class="p">((</span><span class="n">z</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">key</span>
</code></pre></div></div> <p>Each bit of <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, and <code class="language-plaintext highlighter-rouge">z</code> is placed at positions <code class="language-plaintext highlighter-rouge">0,3,6,…</code>, <code class="language-plaintext highlighter-rouge">1,4,7,…</code>, and <code class="language-plaintext highlighter-rouge">2,5,8,…</code>.</p> <hr> <h3 id="step-3-add-batch-id-and-sort">Step 3. Add batch ID and sort</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">batch_id</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">|</span> <span class="nf">morton_encode</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">order</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">argsort</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
</code></pre></div></div> <p>After sorting, the entire cloud becomes a <strong>1D spatial sequence</strong>.</p> <hr> <h2 id="6-what-serialization-enables">6. What serialization enables</h2> <p>By turning 3D space into an ordered sequence, we can now feed the point cloud to <strong>sequence-based models</strong> like Transformers or Mamba.</p> <table> <thead> <tr> <th>Operation</th> <th>Old approach</th> <th>New approach</th> </tr> </thead> <tbody> <tr> <td>Define local region</td> <td>KNN or voxel pooling</td> <td>Z-order window (index range)</td> </tr> <tr> <td>Input structure</td> <td>Set of patches <code class="language-plaintext highlighter-rouge">[N,K,C]</code> </td> <td>Sequence <code class="language-plaintext highlighter-rouge">[L,C]</code> </td> </tr> <tr> <td>Model type</td> <td>Point-based CNN/Transformer</td> <td>State-space or sequence transformer</td> </tr> </tbody> </table> <hr> <h2 id="7-summary">7. Summary</h2> <ol> <li>Discretize coordinates</li> <li>Interleave bits (Morton encoding)</li> <li>Add batch ID to avoid collisions</li> <li>Sort → obtain sequence</li> <li>Feed into Transformer/Mamba</li> </ol> <h2 id="references">References</h2> <ul> <li><a href="https://github.com/microsoft/OCNN" rel="external nofollow noopener" target="_blank">OCNN: Octree-based Sparse CNNs (Wang et al., 2022)</a></li> <li><a href="https://arxiv.org/abs/2408.XXXXX" rel="external nofollow noopener" target="_blank">PointTransformerV3 (Zhao et al., 2024)</a></li> <li><a href="https://en.wikipedia.org/wiki/Z-order_curve" rel="external nofollow noopener" target="_blank">Morton order (Wikipedia)</a></li> <li><a href="https://arxiv.org/abs/2502.XXXXX" rel="external nofollow noopener" target="_blank">PointMamba (2025)</a></li> </ul> </body></html>