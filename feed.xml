<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://antoineach.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="http://antoineach.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-10-28T09:41:12+00:00</updated><id>http://antoineach.github.io//feed.xml</id><title type="html">blank</title><entry><title type="html">Point Transformer v2: Architecture and Implementation Details</title><link href="http://antoineach.github.io//blog/2025/pointTransformerv2/" rel="alternate" type="text/html" title="Point Transformer v2: Architecture and Implementation Details"/><published>2025-10-26T00:00:00+00:00</published><updated>2025-10-26T00:00:00+00:00</updated><id>http://antoineach.github.io//blog/2025/pointTransformerv2</id><content type="html" xml:base="http://antoineach.github.io//blog/2025/pointTransformerv2/"><![CDATA[<h1 id="point-transformer-v2-architecture-et-améliorations">Point Transformer v2: Architecture et Améliorations</h1> <h2 id="introduction">Introduction</h2> <p><strong>Point Transformer v2</strong> améliore significativement son prédécesseur en termes d’efficacité computationnelle et de performances. Les innovations clés incluent :</p> <ul> <li><strong>Grid Pooling</strong> au lieu de Furthest Point Sampling (3-5× plus rapide)</li> <li><strong>Map Unpooling</strong> qui réutilise l’information du downsampling</li> <li><strong>GroupedLinear</strong> pour réduire drastiquement le nombre de paramètres</li> <li><strong>Attention vectorielle enrichie</strong> avec encodage de position sur les values</li> <li><strong>Masking des voisins invalides</strong> pour gérer les nuages de tailles variables</li> </ul> <p>Avant de plonger dans l’architecture globale, commençons par comprendre deux innovations fondamentales : GroupedLinear et GroupedVectorAttention.</p> <hr/> <h2 id="architecture-globale">Architecture Globale</h2> <figure> <picture> <img src="/assets/img/poinTransformerv2/architecture.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>PTv2 suit une architecture U-Net avec :</p> <p><strong>Encodeur (Downsampling):</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input (N points, in_channels)
    ↓ GVAPatchEmbed
N points, 48 channels
    ↓ Encoder 1 (GridPool)
N1 points, 96 channels
    ↓ Encoder 2 (GridPool)
N2 points, 192 channels
    ↓ Encoder 3 (GridPool)
N3 points, 384 channels
    ↓ Encoder 4 (GridPool)
N4 points, 512 channels [BOTTLENECK]
</code></pre></div></div> <p><strong>Décodeur (Upsampling):</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>N4 points, 512 channels
    ↓ Decoder 4 (Unpool + skip)
N3 points, 384 channels
    ↓ Decoder 3 (Unpool + skip)
N2 points, 192 channels
    ↓ Decoder 2 (Unpool + skip)
N1 points, 96 channels
    ↓ Decoder 1 (Unpool + skip)
N points, 48 channels
    ↓ Segmentation Head
N points, num_classes
</code></pre></div></div> <p><strong>Points clés:</strong></p> <ul> <li>Chaque <strong>Encoder</strong> réduit le nombre de points via <strong>GridPool</strong> (voxelisation)</li> <li>Chaque <strong>Decoder</strong> remonte en résolution via <strong>Map Unpooling</strong> + skip connection</li> <li>Les <strong>clusters</strong> stockent le mapping de voxelisation pour l’unpooling</li> <li><strong>Pas de Furthest Point Sampling</strong> → beaucoup plus rapide !</li> </ul> <hr/> <h2 id="groupedlinear--réduction-paramétrique-intelligente">GroupedLinear : Réduction Paramétrique Intelligente</h2> <h3 id="le-problème-avec-linear-classique">Le problème avec Linear classique</h3> <p>Dans un réseau profond, générer des poids d’attention via des couches Linear standard accumule rapidement des paramètres :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Linear classique pour générer 8 poids d'attention depuis 64 features
</span><span class="nc">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="c1"># Paramètres: 64 × 8 = 512 poids + 8 biais = 520 paramètres
</span></code></pre></div></div> <h3 id="linnovation-groupedlinear">L’innovation GroupedLinear</h3> <figure> <picture> <img src="/assets/img/poinTransformerv2/groupedLinear.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>GroupedLinear</strong> remplace la matrice de poids par un <strong>vecteur de poids partagé</strong> :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># GroupedLinear
</span><span class="n">weight</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>  <span class="c1"># UN SEUL vecteur au lieu d'une matrice
# Paramètres: 64 (pas de biais)
</span></code></pre></div></div> <h3 id="fonctionnement-étape-par-étape">Fonctionnement étape par étape</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
    <span class="c1"># input: (N, in_features) = (N, 64)
</span>    <span class="c1"># weight: (1, in_features) = (1, 64)
</span>    
    <span class="c1"># Étape 1: Multiplication élément par élément
</span>    <span class="n">temp</span> <span class="o">=</span> <span class="nb">input</span> <span class="o">*</span> <span class="n">weight</span>  <span class="c1"># (N, in_features)
</span>    
    <span class="c1"># Étape 2: Reshape en groupes
</span>    <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">in_features</span><span class="o">/</span><span class="n">groups</span><span class="p">)</span>
    <span class="c1"># temp: (N, groups, in_features/groups)
</span>    
    <span class="c1"># Étape 3: Somme par groupe
</span>    <span class="n">output</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (N, groups) = (N, out_features)
</span>    
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div> <h3 id="exemple-numérique-concret">Exemple numérique concret</h3> <p>Prenons <strong>N=1, in_features=8, groups=out_features=4</strong> pour simplifier :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Input
</span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># (8,)
</span>
<span class="c1"># Weight (vecteur partagé)
</span><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]</span>  <span class="c1"># (8,)
</span>
<span class="c1"># Étape 1: Multiplication élément par élément
</span><span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="err">×</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">3</span><span class="err">×</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="err">×</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">4</span><span class="err">×</span><span class="mf">0.8</span><span class="p">,</span> <span class="mi">5</span><span class="err">×</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="err">×</span><span class="mf">0.9</span><span class="p">,</span> <span class="mi">3</span><span class="err">×</span><span class="mf">0.4</span><span class="p">,</span> <span class="mi">1</span><span class="err">×</span><span class="mf">0.7</span><span class="p">]</span>
     <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]</span>

<span class="c1"># Étape 2: Reshape en 4 groupes de 2 dimensions
</span><span class="n">temp_grouped</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span>     <span class="c1"># Groupe 0
</span>    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">],</span>     <span class="c1"># Groupe 1
</span>    <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">],</span>     <span class="c1"># Groupe 2
</span>    <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]</span>      <span class="c1"># Groupe 3
</span><span class="p">]</span>

<span class="c1"># Étape 3: Somme par groupe
</span><span class="n">output</span> <span class="o">=</span> <span class="p">[</span>
    <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">3.0</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">,</span>    <span class="c1"># Groupe 0
</span>    <span class="mf">0.2</span> <span class="o">+</span> <span class="mf">3.2</span> <span class="o">=</span> <span class="mf">3.4</span><span class="p">,</span>    <span class="c1"># Groupe 1
</span>    <span class="mf">1.5</span> <span class="o">+</span> <span class="mf">1.8</span> <span class="o">=</span> <span class="mf">3.3</span><span class="p">,</span>    <span class="c1"># Groupe 2
</span>    <span class="mf">1.2</span> <span class="o">+</span> <span class="mf">0.7</span> <span class="o">=</span> <span class="mf">1.9</span>     <span class="c1"># Groupe 3
</span><span class="p">]</span>
<span class="c1"># Résultat: [4.0, 3.4, 3.3, 1.9]
</span></code></pre></div></div> <h3 id="comparaison-des-paramètres">Comparaison des paramètres</h3> <table> <thead> <tr> <th>Configuration</th> <th>Linear classique</th> <th>GroupedLinear</th> <th>Réduction</th> </tr> </thead> <tbody> <tr> <td>64 → 8</td> <td>64×8 = <strong>512</strong></td> <td><strong>64</strong></td> <td>8×</td> </tr> <tr> <td>128 → 16</td> <td>128×16 = <strong>2048</strong></td> <td><strong>128</strong></td> <td>16×</td> </tr> <tr> <td>256 → 32</td> <td>256×32 = <strong>8192</strong></td> <td><strong>256</strong></td> <td>32×</td> </tr> </tbody> </table> <h2 id="groupedlinear-force-le-modèle-à-utiliser-les-mêmes-poids-pour-tous-les-groupes-mais-appliqués-sur-des-portions-différentes-de-linput">GroupedLinear force le modèle à utiliser les mêmes poids pour tous les groupes, mais appliqués sur des portions différentes de l’input.</h2> <h2 id="groupedvectorattention--attention-locale-enrichie">GroupedVectorAttention : Attention Locale Enrichie</h2> <h3 id="vue-densemble">Vue d’ensemble</h3> <p><code class="language-plaintext highlighter-rouge">GroupedVectorAttention</code> est le cœur de PTv2, avec plusieurs améliorations par rapport à PTv1.</p> <figure> <picture> <img src="/assets/img/poinTransformerv2/groupedVectorAttention.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="comparaison-détaillée-avec-ptv1">Comparaison détaillée avec PTv1</h3> <table> <thead> <tr> <th>Aspect</th> <th>PTv1 (PointTransformerLayer)</th> <th>PTv2 (GroupedVectorAttention)</th> </tr> </thead> <tbody> <tr> <td><strong>Projections Q, K, V</strong></td> <td>Simple Linear</td> <td>Linear + <strong>BatchNorm1d + ReLU</strong></td> </tr> <tr> <td><strong>Position Encoding</strong></td> <td>Additif uniquement</td> <td>Additif (+ option multiplicatif)</td> </tr> <tr> <td><strong>Position Encoding sur values</strong></td> <td>❌ Non</td> <td>✅ <strong>Oui</strong></td> </tr> <tr> <td><strong>Masking voisins invalides</strong></td> <td>❌ Non (assume tous valides)</td> <td>✅ <strong>Oui</strong></td> </tr> <tr> <td><strong>Weight generation</strong></td> <td>MLP standard (C×C/G params)</td> <td><strong>GroupedLinear</strong> (C params seulement)</td> </tr> <tr> <td><strong>Normalisation</strong></td> <td>Après weight encoding</td> <td><strong>Avant et après</strong> attention</td> </tr> </tbody> </table> <h3 id="innovation-1--normalisation-des-projections-q-k-v">Innovation 1 : Normalisation des Projections Q, K, V</h3> <p><strong>PTv1 :</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Projections simples sans normalisation
</span><span class="n">self</span><span class="p">.</span><span class="n">linear_q</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">mid_planes</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="n">linear_k</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">mid_planes</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="n">linear_v</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">out_planes</span><span class="p">)</span>

<span class="c1"># Usage
</span><span class="n">query</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">linear_q</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span>  <span class="c1"># (N, C)
</span><span class="n">key</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">linear_k</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span>    <span class="c1"># (N, C)
</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">linear_v</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span>  <span class="c1"># (N, C)
</span></code></pre></div></div> <p><strong>PTv2 :</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Projections avec normalisation et activation
</span><span class="n">self</span><span class="p">.</span><span class="n">linear_q</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
    <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">embed_channels</span><span class="p">,</span> <span class="n">embed_channels</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">qkv_bias</span><span class="p">),</span>
    <span class="nc">PointBatchNorm</span><span class="p">(</span><span class="n">embed_channels</span><span class="p">),</span>  <span class="c1"># Normalisation !
</span>    <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>            <span class="c1"># Activation !
</span><span class="p">)</span>
<span class="c1"># Idem pour linear_k
</span>
<span class="c1"># Usage
</span><span class="n">query</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">linear_q</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span>  <span class="c1"># (N, C) - normalisé et activé
</span></code></pre></div></div> <p><strong>Pourquoi c’est important ?</strong></p> <p>La normalisation des Q, K stabilise l’entraînement en évitant des valeurs extrêmes dans la relation Q-K :</p> <p><strong>Impact :</strong> Convergence plus rapide et training plus stable.</p> <hr/> <h3 id="innovation-2--position-encoding-sur-les-values">Innovation 2 : Position Encoding sur les Values</h3> <p><strong>PTv1 :</strong> L’encodage de position n’est ajouté qu’à la relation Q-K</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Code PTv1 (simplifié)
</span><span class="n">relative_positions</span> <span class="o">=</span> <span class="n">neighbor_positions</span> <span class="o">-</span> <span class="n">query_position</span>  <span class="c1"># (N, K, 3)
</span><span class="n">encoded_positions</span> <span class="o">=</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">relative_positions</span><span class="p">)</span>               <span class="c1"># (N, K, out_dim)
</span>
<span class="c1"># Application UNIQUEMENT sur relation Q-K
</span><span class="n">relation_qk</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span> <span class="o">-</span> <span class="n">query</span><span class="p">)</span> <span class="o">+</span> <span class="n">encoded_positions</span>
<span class="c1"># Les values ne sont PAS modifiées par la géométrie
</span>
</code></pre></div></div> <p><strong>PTv2 :</strong> L’encodage est ajouté à la relation Q-K <strong>ET aux values</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Code PTv2
</span><span class="n">pe_bias</span> <span class="o">=</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">relative_positions</span><span class="p">)</span>  <span class="c1"># (N, K, C)
</span>
<span class="c1"># Sur la relation Q-K (comme PTv1)
</span><span class="n">relation_qk</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span> <span class="o">-</span> <span class="n">query</span><span class="p">)</span> <span class="o">+</span> <span class="n">pe_bias</span>

<span class="c1"># NOUVEAU: aussi sur les values !
</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="n">pe_bias</span>

<span class="c1"># (values contiennent maintenant l'info géométrique)
</span></code></pre></div></div> <h3 id="innovation-3--masking-des-voisins-invalides">Innovation 3 : Masking des Voisins Invalides</h3> <p><strong>Contexte : Différence Fondamentale entre PTv1 et PTv2</strong></p> <h4 id="ptv1--k-nn-garantit-toujours-k-voisins">PTv1 : K-NN garantit toujours K voisins</h4> <p>Dans PTv1, les voisins sont trouvés via <strong>K-Nearest Neighbors (K-NN)</strong> :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PTv1 - Dans chaque PointTransformerLayer
</span><span class="n">x_k</span> <span class="o">=</span> <span class="n">pointops</span><span class="p">.</span><span class="nf">queryandgroup</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">nsample</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">x_k</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">use_xyz</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># Retourne TOUJOURS exactement K voisins (via K-NN search)
</span></code></pre></div></div> <p><strong>PTv1 n’a donc pas besoin de masking</strong> : tous les K voisins sont valides (même si certains peuvent être très éloignés).</p> <hr/> <h4 id="ptv2--grid-pooling-peut-avoir--k-voisins">PTv2 : Grid Pooling peut avoir &lt; K voisins</h4> <p>Dans PTv2, les voisins sont déterminés par <strong>Grid Pooling</strong> (voxelisation), qui peut créer des régions avec moins de K points.</p> <p><strong>Rappel : Qu’est-ce que le Grid Pooling ?</strong></p> <p>Le <strong>Grid Pooling</strong> partitionne l’espace en <strong>voxels</strong> (cubes 3D de taille <code class="language-plaintext highlighter-rouge">grid_size</code>) et agrège tous les points d’un même voxel :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Avant Grid Pooling (N=16 points):

        grid_size = 0.5m
      
            ┌─────┬─────┬─────┬─────┐
            │ ●●  │     │  ●  │     │
            │ ●   │     │     │     │
            ├─────┼─────┼─────┼─────┤
            │  ●  │ ●●  │     │     │
            │     │  ●  │     │     │
            ├─────┼─────┼─────┼─────┤
            │     │  ●  │ ●   │  ●  │
            │  ●  │     │   ● │     │
            ├─────┼─────┼─────┼─────┤
            │  ●  │     │     │     │
            │     │  ●  │  ●  │     │
            └─────┴─────┴─────┴─────┘

Après Grid Pooling (M=10 voxels):
    
    ┌─────┬─────┬─────┬─────┐
    │  ◉ │     │  ◉  │     │  ← 1 point par voxel occupé
    │     │     │     │     │
    ├─────┼─────┼─────┼─────┤
    │  ◉  │  ◉  │     │     │
    │     │     │     │     │
    ├─────┼─────┼─────┼─────┤
    │  ◉  │  ◉  │  ◉  │  ◉  │
    │     │     │     │     │
    ├─────┼─────┼─────┼─────┤
    │  ◉  │  ◉  │     │     │
    │     │     │     │     │
    └─────┴─────┴─────┴─────┘
</code></pre></div></div> <p><strong>Conséquence :</strong> Après Grid Pooling, certaines zones peuvent être <strong>peu denses</strong> :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Configuration: K=8 voisins demandés

Zone dense:                   Zone peu dense (bord du nuage):
    ◉  ◉  ◉                       ◉
    ◉  ●  ◉                          
    ◉  ◉  ◉                               ◉
    
Point ● a 8 voisins ✓         Point ◉ a seulement 2 voisins ✗
</code></pre></div></div> <p><strong>Comment PTv2 gère-t-il le manque de voisins ?</strong></p> <p>Lors du K-NN sur les voxels poolés, si un voxel a moins de K voisins disponibles, les indices manquants sont marqués par <strong>-1</strong> :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PTv2 - K-NN sur les voxels après Grid Pooling
</span><span class="n">reference_index</span> <span class="o">=</span> <span class="nf">knn_query</span><span class="p">(</span><span class="n">K</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">coord_pooled</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
<span class="c1"># reference_index: (M, K)
</span>
<span class="c1"># Exemple pour un voxel isolé
</span><span class="n">reference_index</span><span class="p">[</span><span class="n">voxel_42</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="c1">#                            ↑───↑   ↑──────────────────────↑
#                            2 voisins    6 indices invalides (-1)
</span></code></pre></div></div> <p><strong>Pourquoi -1 et pas juste moins d’indices ?</strong></p> <p>Pour garder une <strong>shape uniforme</strong> <code class="language-plaintext highlighter-rouge">(M, K)</code> compatible avec les opérations matricielles :</p> <ul> <li>Tous les tensors ont la même forme</li> <li>Permet le batching efficace sur GPU</li> <li>Le padding avec -1 permet le masking explicite</li> </ul> <hr/> <p><strong>Solution PTv2 : Masking Explicite</strong></p> <p><strong>Étape 1 : Création du masque</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># reference_index contient -1 pour les voisins invalides
</span><span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="n">reference_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># (M, K)
</span>
<span class="c1"># Comportement de sign(x+1):
# Si reference_index[i] = -1  → sign(-1+1) = sign(0) = 0  ← invalide
# Si reference_index[i] ≥ 0   → sign(≥1) = 1             ← valide
</span></code></pre></div></div> <p><strong>Étape 2 : Application sur les poids d’attention</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Dans GroupedVectorAttention, après softmax
</span><span class="n">attention_weights</span> <span class="o">=</span> <span class="nf">softmax</span><span class="p">(</span><span class="n">attention_scores</span><span class="p">)</span>  <span class="c1"># (M, K, groups)
</span>
<span class="c1"># Application du masque
</span><span class="n">attention_weights</span> <span class="o">=</span> <span class="n">attention_weights</span> <span class="o">*</span> <span class="n">mask</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Shape: (M, K, groups) × (M, K, 1) → (M, K, groups)
</span></code></pre></div></div> <p><strong>Visualisation :</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Avant masking (après softmax sur K voisins)
</span><span class="n">attention_weights</span><span class="p">[</span><span class="n">voxel_42</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mf">0.20</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">,</span> <span class="p">...],</span>  <span class="c1"># Voisin 15 (valide)
</span>    <span class="p">[</span><span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.09</span><span class="p">,</span> <span class="p">...],</span>  <span class="c1"># Voisin 23 (valide)
</span>    <span class="p">[</span><span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.14</span><span class="p">,</span> <span class="mf">0.11</span><span class="p">,</span> <span class="p">...],</span>  <span class="c1"># Padding -1 (invalide mais a des poids !)
</span>    <span class="p">[</span><span class="mf">0.11</span><span class="p">,</span> <span class="mf">0.13</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">,</span> <span class="p">...],</span>  <span class="c1"># Padding -1 (invalide)
</span>    <span class="p">[</span><span class="mf">0.10</span><span class="p">,</span> <span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.12</span><span class="p">,</span> <span class="p">...],</span>  <span class="c1"># Padding -1 (invalide)
</span>    <span class="p">[</span><span class="mf">0.09</span><span class="p">,</span> <span class="mf">0.11</span><span class="p">,</span> <span class="mf">0.13</span><span class="p">,</span> <span class="p">...],</span>  <span class="c1"># Padding -1 (invalide)
</span>    <span class="p">[</span><span class="mf">0.10</span><span class="p">,</span> <span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.18</span><span class="p">,</span> <span class="p">...],</span>  <span class="c1"># Padding -1 (invalide)
</span>    <span class="p">[</span><span class="mf">0.10</span><span class="p">,</span> <span class="mf">0.11</span><span class="p">,</span> <span class="mf">0.17</span><span class="p">,</span> <span class="p">...],</span>  <span class="c1"># Padding -1 (invalide)
</span><span class="p">]</span>

<span class="c1"># Après masking
</span><span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="n">attention_weights</span><span class="p">[</span><span class="n">voxel_42</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mf">0.20</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">,</span> <span class="p">...],</span>  <span class="c1"># Voisin 15 ✓
</span>    <span class="p">[</span><span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.09</span><span class="p">,</span> <span class="p">...],</span>  <span class="c1"># Voisin 23 ✓
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">...],</span>            <span class="c1"># Annulé ✓
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">...],</span>            <span class="c1"># Annulé ✓
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">...],</span>            <span class="c1"># Annulé ✓
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">...],</span>            <span class="c1"># Annulé ✓
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">...],</span>            <span class="c1"># Annulé ✓
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">...],</span>            <span class="c1"># Annulé ✓
</span><span class="p">]</span>
</code></pre></div></div> <p><strong>Étape 3 : Agrégation</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Agrégation finale (somme pondérée)
</span><span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">value_grouped</span> <span class="o">*</span> <span class="n">attention_weights</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)).</span><span class="nf">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Les voisins invalides (poids=0) ne contribuent pas ✓
</span></code></pre></div></div> <hr/> <p><strong>Pourquoi c’est Crucial ?</strong></p> <p><strong>Sans masking</strong>, les voisins padding contribueraient avec des <strong>features aléatoires</strong> :</p> <hr/> <h3 id="innovation-4--groupedlinear-pour-les-poids-dattention">Innovation 4 : GroupedLinear pour les Poids d’Attention</h3> <p>Au lieu d’un MLP standard <code class="language-plaintext highlighter-rouge">Linear(C, groups)</code> avec C×groups paramètres, PTv2 utilise <code class="language-plaintext highlighter-rouge">GroupedLinear(C, groups)</code> avec seulement C paramètres.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PTv1: MLP standard
</span><span class="n">self</span><span class="p">.</span><span class="n">linear_w</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
    <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">mid_planes</span><span class="p">,</span> <span class="n">mid_planes</span> <span class="o">//</span> <span class="n">share_planes</span><span class="p">),</span>  <span class="c1"># C × C/G paramètres
</span>    <span class="bp">...</span>
<span class="p">)</span>

<span class="c1"># PTv2: avec GroupedLinear
</span><span class="n">self</span><span class="p">.</span><span class="n">weight_encoding</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
    <span class="nc">GroupedLinear</span><span class="p">(</span><span class="n">embed_channels</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">groups</span><span class="p">),</span>  <span class="c1"># Seulement C paramètres !
</span>    <span class="bp">...</span>
<span class="p">)</span>
</code></pre></div></div> <p><strong>Gain :</strong> moins de paramètres pour générer les poids d’attention, sans perte de performance.</p> <h3 id="innovation-5--architecture-de-normalisation">Innovation 5 : Architecture de Normalisation</h3> <p><strong>PTv1 :</strong> Normalisation minimale</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PTv1 - Pas de normalisation sur les projections Q, K, V
</span><span class="n">query</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Pas normalisé
</span><span class="n">key</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">value</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Normalisation seulement dans le MLP des poids
</span><span class="n">attention_scores</span> <span class="o">=</span> <span class="nc">MLP_with_BatchNorm</span><span class="p">(</span><span class="n">relation_qk</span><span class="p">)</span>
</code></pre></div></div> <p><strong>PTv2 :</strong> Normalisation extensive</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PTv2 - Normalisation partout
</span><span class="n">query</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="err">→</span> <span class="n">BatchNorm</span> <span class="err">→</span> <span class="n">ReLU</span>  <span class="c1"># Normalisé
</span><span class="n">key</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="err">→</span> <span class="n">BatchNorm</span> <span class="err">→</span> <span class="n">ReLU</span>
<span class="n">value</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Pas d'activation (reste linéaire)
</span>
<span class="c1"># Position encoding aussi normalisé
</span><span class="n">pe_bias</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="err">→</span> <span class="n">BatchNorm</span> <span class="err">→</span> <span class="n">ReLU</span> <span class="err">→</span> <span class="n">Linear</span>

<span class="c1"># Weight encoding aussi normalisé
</span><span class="n">attention_scores</span> <span class="o">=</span> <span class="n">GroupedLinear</span> <span class="err">→</span> <span class="n">BatchNorm</span> <span class="err">→</span> <span class="n">ReLU</span> <span class="err">→</span> <span class="n">Linear</span>
</code></pre></div></div> <p><strong>Impact :</strong> Training plus stable, convergence plus rapide, moins sensible aux hyperparamètres.</p> <hr/> <h1 id="block-et-blocksequence--architecture-résiduelle">Block et BlockSequence : Architecture Résiduelle</h1> <h2 id="block--residual-block-avec-droppath">Block : Residual Block avec DropPath</h2> <p>Le <code class="language-plaintext highlighter-rouge">Block</code> de PTv2 encapsule <code class="language-plaintext highlighter-rouge">GroupedVectorAttention</code> dans une structure résiduelle similaire à ResNet, avec une innovation clé : <strong>DropPath</strong>.</p> <figure> <picture> <img src="/assets/img/poinTransformerv2/block.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="comparaison-avec-ptv1">Comparaison avec PTv1</h3> <table> <thead> <tr> <th>Aspect</th> <th>PTv1 (PointTransformerBlock)</th> <th>PTv2 (Block)</th> </tr> </thead> <tbody> <tr> <td><strong>Structure</strong></td> <td>Linear → Attention → Linear + Skip</td> <td>Linear → Attention → Linear + Skip</td> </tr> <tr> <td><strong>Régularisation</strong></td> <td>Dropout uniquement</td> <td><strong>DropPath</strong> + Dropout</td> </tr> <tr> <td><strong>Normalisation</strong></td> <td>3× BatchNorm</td> <td>3× BatchNorm (identique)</td> </tr> <tr> <td><strong>Skip connection</strong></td> <td>Simple addition</td> <td>Addition avec <strong>DropPath</strong></td> </tr> </tbody> </table> <h3 id="architecture-détaillée">Architecture Détaillée</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input features (N, C)
    ↓
[Linear + BatchNorm1d + ReLU]  ← Pre-activation (expansion)
    ↓
[GroupedVectorAttention]  ← Attention locale sur K voisins
    ↓
[BatchNorm1d + ReLU]  ← Post-attention normalization
    ↓
[Linear + BatchNorm1d]  ← Projection
    ↓
[DropPath]  ← Régularisation stochastique (NOUVEAU)
    ↓
[+ Skip Connection]  ← Connexion résiduelle
    ↓
[ReLU]  ← Activation finale
    ↓
Output features (N, C)
</code></pre></div></div> <h3 id="droppath--stochastic-depth">DropPath : Stochastic Depth</h3> <p><strong>DropPath</strong> (Stochastic Depth) est une technique de régularisation qui <strong>dropout des chemins entiers</strong> dans un réseau résiduel, plutôt que des neurones individuels.</p> <p><strong>Dropout classique vs DropPath :</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Dropout classique (agit sur les features)
</span><span class="k">def</span> <span class="nf">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="nf">random</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">p</span>  <span class="c1"># Masque aléatoire par élément
</span>    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">mask</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="nf">dropout</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="c1"># Certaines features de f(x) sont mises à 0
</span>

<span class="c1"># DropPath (agit sur le chemin entier)
</span><span class="k">def</span> <span class="nf">drop_path</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">training</span> <span class="ow">and</span> <span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># Tout le chemin est ignoré !
</span>    <span class="k">return</span> <span class="n">x</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="nf">drop_path</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="c1"># Soit tout f(x) est gardé, soit tout est ignoré
</span></code></pre></div></div> <p><strong>Fonctionnement en pratique :</strong></p> <p>Durant l’entraînement, avec probabilité <code class="language-plaintext highlighter-rouge">drop_path_rate</code> (typiquement 0.1), on saute complètement le bloc transformé :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Sans DropPath (PTv1)
</span><span class="n">feat_transformed</span> <span class="o">=</span> <span class="n">Linear</span> <span class="err">→</span> <span class="n">Attention</span> <span class="err">→</span> <span class="n">Linear</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">identity</span> <span class="o">+</span> <span class="n">feat_transformed</span>  <span class="c1"># Toujours calculé
</span>
<span class="c1"># Avec DropPath (PTv2)
</span><span class="n">feat_transformed</span> <span class="o">=</span> <span class="n">Linear</span> <span class="err">→</span> <span class="n">Attention</span> <span class="err">→</span> <span class="n">Linear</span>

<span class="k">if</span> <span class="n">training</span> <span class="ow">and</span> <span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">drop_path_rate</span><span class="p">:</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">identity</span>  <span class="c1"># On saute feat_transformed complètement !
</span><span class="k">else</span><span class="p">:</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">identity</span> <span class="o">+</span> <span class="n">feat_transformed</span>

<span class="c1"># À l'inférence
</span><span class="n">output</span> <span class="o">=</span> <span class="n">identity</span> <span class="o">+</span> <span class="n">feat_transformed</span>  <span class="c1"># Toujours actif
</span></code></pre></div></div> <p><strong>Visualisation sur un réseau de 12 blocs :</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Avec drop_path_rate = 0.1 (10% de chance de drop par bloc)

Training iteration 1:
Input → [Block1] → [Block2] → [SKIP] → [Block4] → ... → [SKIP] → [Block12]
        ✓          ✓          ✗          ✓              ✗          ✓
        (réseau de ~10 blocs actifs)

Training iteration 2:
Input → [Block1] → [SKIP] → [Block3] → [Block4] → ... → [Block11] → [Block12]
        ✓          ✗        ✓          ✓                  ✓          ✓
        (réseau de ~11 blocs actifs)

Inference:
Input → [Block1] → [Block2] → [Block3] → [Block4] → ... → [Block11] → [Block12]
        ✓          ✓          ✓          ✓                  ✓          ✓
        (tous les 12 blocs actifs)
</code></pre></div></div> <p><strong>Cependant, dans PTv2, le <code class="language-plaintext highlighter-rouge">drop_path_rate</code> est implémenté mais laissé à 0.0. Autrement dit, il n’est pas utilisé.</strong></p> <h2 id="blocksequence--réutilisation-du-k-nn">BlockSequence : Réutilisation du K-NN</h2> <p><code class="language-plaintext highlighter-rouge">BlockSequence</code> empile plusieurs <code class="language-plaintext highlighter-rouge">Block</code> et introduit une optimisation majeure : <strong>partage du reference_index</strong>.</p> <figure> <picture> <img src="/assets/img/poinTransformerv2/blockSequence.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="innovation-clé--k-nn-calculé-une-seule-fois">Innovation Clé : K-NN Calculé Une Seule Fois</h3> <p><strong>Problème PTv1 :</strong></p> <p>Dans PTv1, chaque <code class="language-plaintext highlighter-rouge">PointTransformerLayer</code> recalcule les K plus proches voisins via K-NN :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PTv1 - Dans PointTransformerLayer.forward()
</span><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pxo</span><span class="p">):</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="n">pxo</span>
    
    <span class="c1"># K-NN calculé À CHAQUE COUCHE
</span>    <span class="n">x_k</span> <span class="o">=</span> <span class="n">pointops</span><span class="p">.</span><span class="nf">queryandgroup</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">nsample</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">x_k</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">use_xyz</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">x_v</span> <span class="o">=</span> <span class="n">pointops</span><span class="p">.</span><span class="nf">queryandgroup</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">nsample</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">x_v</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">use_xyz</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="c1"># ...
</span></code></pre></div></div> <p>Pour un bloc avec 6 couches <code class="language-plaintext highlighter-rouge">PointTransformerLayer</code>, on fait <strong>6 fois</strong> la même recherche K-NN !</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bloc avec 6 couches PTv1:
Layer 1: K-NN (N points, find K=16 neighbors) → O(N log N)
Layer 2: K-NN (N points, find K=16 neighbors) → O(N log N)
Layer 3: K-NN (N points, find K=16 neighbors) → O(N log N)
Layer 4: K-NN (N points, find K=16 neighbors) → O(N log N)
Layer 5: K-NN (N points, find K=16 neighbors) → O(N log N)
Layer 6: K-NN (N points, find K=16 neighbors) → O(N log N)

Coût total: 6 × O(N log N)
</code></pre></div></div> <p><strong>Solution PTv2 :</strong></p> <p>Dans PTv2, <code class="language-plaintext highlighter-rouge">BlockSequence</code> calcule le K-NN <strong>une seule fois</strong> au début et tous les <code class="language-plaintext highlighter-rouge">Block</code> partagent le même <code class="language-plaintext highlighter-rouge">reference_index</code> :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PTv2 - Dans BlockSequence.forward()
</span><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">coord</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">points</span>
    
    <span class="c1"># K-NN calculé UNE SEULE FOIS au début
</span>    <span class="n">reference_index</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pointops</span><span class="p">.</span><span class="nf">knn_query</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">neighbours</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
    <span class="c1"># reference_index: (N, K) - indices des K voisins pour chaque point
</span>    
    <span class="c1"># Tous les blocks partagent le même reference_index
</span>    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">blocks</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="nf">block</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">reference_index</span><span class="p">)</span>  <span class="c1"># Pas de recalcul !
</span>    
    <span class="k">return</span> <span class="n">points</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bloc avec 6 couches PTv2:
K-NN (une fois): O(N log N)
Layer 1: Utilise reference_index → O(1) lookup
Layer 2: Utilise reference_index → O(1) lookup
Layer 3: Utilise reference_index → O(1) lookup
Layer 4: Utilise reference_index → O(1) lookup
Layer 5: Utilise reference_index → O(1) lookup
Layer 6: Utilise reference_index → O(1) lookup

Coût total: O(N log N)  ← 6× plus rapide !
</code></pre></div></div> <h3 id="pourquoi-cest-valide-">Pourquoi c’est Valide ?</h3> <p><strong>Question :</strong> Peut-on vraiment réutiliser les mêmes voisins à travers toutes les couches ?</p> <p><strong>Réponse :</strong> <strong>OUI</strong>, car dans <code class="language-plaintext highlighter-rouge">BlockSequence</code>, les <strong>positions ne changent pas</strong> !</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Dans Block.forward()
</span><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">reference_index</span><span class="p">):</span>
    <span class="n">coord</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">points</span>
    
    <span class="c1"># coord (positions) reste INCHANGÉ à travers le bloc
</span>    <span class="n">feat</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">fc1</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span>  <span class="c1"># Seulement les features changent
</span>    <span class="n">feat</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">attn</span><span class="p">(</span><span class="n">feat</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">reference_index</span><span class="p">)</span>  <span class="c1"># coord fixe
</span>    <span class="n">feat</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">fc3</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span>
    <span class="c1"># ...
</span>    
    <span class="k">return</span> <span class="p">[</span><span class="n">coord</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="n">offset</span><span class="p">]</span>  <span class="c1"># coord identique en sortie
</span></code></pre></div></div> <p>Les positions 3D (<code class="language-plaintext highlighter-rouge">coord</code>) sont <strong>constantes</strong> dans un <code class="language-plaintext highlighter-rouge">BlockSequence</code> - seules les <strong>features</strong> évoluent. Les K plus proches voisins restent donc identiques géométriquement !</p> <p><strong>Cas où on DOIT recalculer le K-NN :</strong></p> <p>Les positions changent uniquement lors des transitions entre niveaux de l’architecture (downsampling/upsampling) :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Encoder
</span><span class="n">points</span> <span class="o">=</span> <span class="nc">BlockSequence</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>  <span class="c1"># Positions fixes, K-NN partagé ✓
</span><span class="n">points</span> <span class="o">=</span> <span class="nc">GridPool</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>        <span class="c1"># Positions changent (downsampling) ✗
</span><span class="n">points</span> <span class="o">=</span> <span class="nc">BlockSequence</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>  <span class="c1"># Nouvelles positions → nouveau K-NN ✓
</span>
<span class="c1"># Decoder
</span><span class="n">points</span> <span class="o">=</span> <span class="nc">UnpoolWithSkip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">skip</span><span class="p">)</span>  <span class="c1"># Positions changent (upsampling) ✗
</span><span class="n">points</span> <span class="o">=</span> <span class="nc">BlockSequence</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>         <span class="c1"># Nouvelles positions → nouveau K-NN ✓
</span></code></pre></div></div> <hr/> <h2 id="gvapatchembed--embedding-initial">GVAPatchEmbed : Embedding Initial</h2> <p>Avant de downsampler, PTv2 applique un <code class="language-plaintext highlighter-rouge">GVAPatchEmbed</code> qui enrichit les features à pleine résolution.</p> <figure> <picture> <img src="/assets/img/poinTransformerv2/GVAPatchEmbed.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="rôle">Rôle</h3> <p><strong>GVAPatchEmbed</strong> = Projection linéaire + BlockSequence (sans downsampling)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Input</span><span class="p">:</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">)</span>
    <span class="err">↓</span>
<span class="n">Linear</span> <span class="o">+</span> <span class="n">BatchNorm1d</span> <span class="o">+</span> <span class="n">ReLU</span>
    <span class="err">↓</span>
<span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">embed_channels</span><span class="p">)</span>
    <span class="err">↓</span>
<span class="nc">BlockSequence </span><span class="p">(</span><span class="n">depth</span> <span class="n">blocks</span><span class="p">)</span>
    <span class="err">↓</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">embed_channels</span><span class="p">)</span>
</code></pre></div></div> <h1 id="gridpool--downsampling-par-voxelisation">GridPool : Downsampling par Voxelisation</h1> <h2 id="vue-densemble-1">Vue d’ensemble</h2> <p><code class="language-plaintext highlighter-rouge">GridPool</code> est l’une des innovations majeures de PTv2, remplaçant le <strong>Furthest Point Sampling (FPS)</strong> de PTv1 par une approche basée sur la <strong>voxelisation</strong>.</p> <figure> <picture> <img src="/assets/img/poinTransformerv2/gridPool.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h4 id="voxelisation">Voxelisation</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Normalisation des coordonnées par rapport au début de chaque nuage
</span><span class="n">coord_normalized</span> <span class="o">=</span> <span class="n">coord</span> <span class="o">-</span> <span class="n">start</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>  <span class="c1"># (N, 3)
</span>
<span class="c1"># Assignation à une grille avec voxels de taille grid_size
</span><span class="n">cluster</span> <span class="o">=</span> <span class="nf">voxel_grid</span><span class="p">(</span>
    <span class="n">pos</span><span class="o">=</span><span class="n">coord_normalized</span><span class="p">,</span> 
    <span class="n">size</span><span class="o">=</span><span class="n">grid_size</span><span class="p">,</span>  <span class="c1"># ex: 0.06m
</span>    <span class="n">batch</span><span class="o">=</span><span class="n">batch</span><span class="p">,</span>
    <span class="n">start</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
<span class="c1"># cluster: (N,) - ID du voxel pour chaque point
</span></code></pre></div></div> <p><strong>Exemple avec grid_size=1.0 :</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Points d'un nuage (après normalisation)
</span><span class="n">points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>  <span class="c1"># Voxel (0, 0, 0)
</span>    <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>  <span class="c1"># Voxel (0, 0, 0)
</span>    <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span>  <span class="c1"># Voxel (1, 0, 0)
</span>    <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>  <span class="c1"># Voxel (1, 1, 0)
</span>    <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span>  <span class="c1"># Voxel (0, 1, 0)
</span><span class="p">]</span>

<span class="c1"># Calcul du voxel ID
</span><span class="n">voxel_id</span> <span class="o">=</span> <span class="nf">floor</span><span class="p">(</span><span class="n">coord</span> <span class="o">/</span> <span class="n">grid_size</span><span class="p">)</span>

<span class="n">cluster</span> <span class="o">=</span> <span class="p">[</span>
    <span class="mi">0</span><span class="p">,</span>  <span class="c1"># (0,0,0) → ID unique du voxel
</span>    <span class="mi">0</span><span class="p">,</span>  <span class="c1"># (0,0,0) → même voxel
</span>    <span class="mi">1</span><span class="p">,</span>  <span class="c1"># (1,0,0)
</span>    <span class="mi">2</span><span class="p">,</span>  <span class="c1"># (1,1,0)
</span>    <span class="mi">3</span><span class="p">,</span>  <span class="c1"># (0,1,0)
</span><span class="p">]</span>
</code></pre></div></div> <h4 id="étape-4--identification-des-voxels-uniques">Étape 4 : Identification des Voxels Uniques</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">unique</span><span class="p">,</span> <span class="n">cluster_inverse</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">unique</span><span class="p">(</span>
    <span class="n">cluster</span><span class="p">,</span> 
    <span class="nb">sorted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> 
    <span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> 
    <span class="n">return_counts</span><span class="o">=</span><span class="bp">True</span>
<span class="p">)</span>
</code></pre></div></div> <p><strong>Que retourne torch.unique ?</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Input cluster (exemple)
</span><span class="n">cluster</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1">#          ↑─────↑  ↑──↑  ↑────────↑  ↑──────↑
#          3 pts   2 pts  4 points   3 points
</span>
<span class="n">unique</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># Les voxels uniques
# Nvoxel = 4
</span>
<span class="n">cluster_inverse</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1"># Mapping: point i appartient au voxel unique[cluster_inverse[i]]
</span>
<span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># Nombre de points par voxel
</span></code></pre></div></div> <h4 id="étape-5--tri-et-index-pointers">Étape 5 : Tri et Index Pointers</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Tri les points par voxel
</span><span class="n">_</span><span class="p">,</span> <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">cluster_inverse</span><span class="p">)</span>
<span class="c1"># sorted_indices: ordre pour regrouper les points du même voxel ensemble
</span>
<span class="c1"># Création des pointeurs pour chaque voxel
</span><span class="n">idx_ptr</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span>
    <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> 
    <span class="n">torch</span><span class="p">.</span><span class="nf">cumsum</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="p">])</span>
<span class="c1"># idx_ptr: (Nvoxel + 1,)
</span></code></pre></div></div> <p><strong>Exemple :</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Après tri
</span><span class="n">sorted_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="c1"># Points triés par voxel
</span>
<span class="c1"># Index pointers
</span><span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">idx_ptr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span>
<span class="c1">#          ↑  ↑  ↑  ↑  ↑
#          │  │  │  │  └─ Fin (12 points)
#          │  │  │  └──── Voxel 3 commence à l'indice 9
#          │  │  └─────── Voxel 2 commence à l'indice 5
#          │  └────────── Voxel 1 commence à l'indice 3
#          └───────────── Voxel 0 commence à l'indice 0
</span></code></pre></div></div> <h4 id="étape-6--agrégation-des-coordonnées-moyenne">Étape 6 : Agrégation des Coordonnées (Moyenne)</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">coord_pooled</span> <span class="o">=</span> <span class="nf">segment_csr</span><span class="p">(</span>
    <span class="n">coord</span><span class="p">[</span><span class="n">sorted_indices</span><span class="p">],</span>  <span class="c1"># Coordonnées triées par voxel
</span>    <span class="n">idx_ptr</span><span class="p">,</span> 
    <span class="nb">reduce</span><span class="o">=</span><span class="sh">"</span><span class="s">mean</span><span class="sh">"</span>
<span class="p">)</span>
<span class="c1"># coord_pooled: (Nvoxel, 3)
# Position moyenne de tous les points dans chaque voxel
</span></code></pre></div></div> <p><strong>Exemple :</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Voxel 0 contient 3 points aux positions:
</span><span class="n">points_voxel_0</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">]]</span>
<span class="n">coord_pooled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nf">mean</span><span class="p">(</span><span class="n">points_voxel_0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.37</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">]</span>

<span class="c1"># Voxel 1 contient 2 points:
</span><span class="n">points_voxel_1</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]]</span>
<span class="n">coord_pooled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nf">mean</span><span class="p">(</span><span class="n">points_voxel_1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">]</span>
</code></pre></div></div> <h4 id="étape-7--agrégation-des-features-max">Étape 7 : Agrégation des Features (Max)</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">feat_pooled</span> <span class="o">=</span> <span class="nf">segment_csr</span><span class="p">(</span>
    <span class="n">feat</span><span class="p">[</span><span class="n">sorted_indices</span><span class="p">],</span>  <span class="c1"># Features triées par voxel
</span>    <span class="n">idx_ptr</span><span class="p">,</span>
    <span class="nb">reduce</span><span class="o">=</span><span class="sh">"</span><span class="s">max</span><span class="sh">"</span>
<span class="p">)</span>
<span class="c1"># feat_pooled: (Nvoxel, out_channels)
# Maximum des features dans chaque voxel
</span></code></pre></div></div> <p><strong>Pourquoi Max au lieu de Mean ?</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Exemple avec 3 points dans un voxel
</span>
<span class="c1"># Mean pooling
</span><span class="n">feat_mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">feat1</span> <span class="o">+</span> <span class="n">feat2</span> <span class="o">+</span> <span class="n">feat3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
<span class="c1"># Peut "diluer" les features importantes
</span>
<span class="c1"># Max pooling (utilisé par PTv2)
</span><span class="n">feat_max</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">feat1</span><span class="p">,</span> <span class="n">feat2</span><span class="p">,</span> <span class="n">feat3</span><span class="p">)</span>
<span class="c1"># Préserve les features dominantes de chaque canal
# Plus robuste au bruit et aux outliers
</span></code></pre></div></div> <h4 id="étape-8--reconstruction-des-offsets">Étape 8 : Reconstruction des Offsets</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Récupération du batch ID pour chaque voxel
# (prend le batch du premier point de chaque voxel)
</span><span class="n">batch_pooled</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="n">idx_ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="c1"># batch_pooled: (Nvoxel,)
</span>
<span class="c1"># Conversion batch → offset
</span><span class="n">offset_pooled</span> <span class="o">=</span> <span class="nf">batch2offset</span><span class="p">(</span><span class="n">batch_pooled</span><span class="p">)</span>
<span class="c1"># offset_pooled: (B,)
</span></code></pre></div></div> <h4 id="étape-9--retour-du-cluster-mapping">Étape 9 : Retour du Cluster Mapping</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="p">[</span><span class="n">coord_pooled</span><span class="p">,</span> <span class="n">feat_pooled</span><span class="p">,</span> <span class="n">offset_pooled</span><span class="p">],</span> <span class="n">cluster_inverse</span>
</code></pre></div></div> <p>Le <code class="language-plaintext highlighter-rouge">cluster_inverse</code> est <strong>crucial</strong> car il permet le <strong>Map Unpooling</strong> plus tard :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># cluster_inverse: (N,) - pour chaque point, son voxel d'appartenance
</span><span class="n">cluster_inverse</span><span class="p">[</span><span class="n">point_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">voxel_id</span>

<span class="c1"># Exemple
</span><span class="n">cluster_inverse</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1">#                  ↑─────↑  ↑──↑  ↑────────↑  ↑──────↑
#                  Points du voxel 0, 1, 2, 3
</span></code></pre></div></div> <p>Ce mapping sera réutilisé dans <code class="language-plaintext highlighter-rouge">UnpoolWithSkip</code> pour “dépooler” efficacement !</p> <hr/> <h3 id="4-map-unpooling-gratuit">4. Map Unpooling Gratuit</h3> <p>Le <code class="language-plaintext highlighter-rouge">cluster_inverse</code> permet un unpooling <strong>sans calcul</strong> :</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PTv1: doit recalculer K-NN pour l'interpolation
</span><span class="n">upsampled</span> <span class="o">=</span> <span class="nf">knn_interpolation</span><span class="p">(</span><span class="n">low_res</span><span class="p">,</span> <span class="n">high_res</span><span class="p">)</span>  <span class="c1"># Coûteux !
</span>
<span class="c1"># PTv2: réutilise le cluster mapping
</span><span class="n">upsampled</span> <span class="o">=</span> <span class="n">feat_low_res</span><span class="p">[</span><span class="n">cluster_inverse</span><span class="p">]</span>  <span class="c1"># Lookup instantané !
</span></code></pre></div></div> <h1 id="unpoolwithskip--map-unpooling-avec-skip-connections">UnpoolWithSkip : Map Unpooling avec Skip Connections</h1> <h2 id="vue-densemble-2">Vue d’ensemble</h2> <p><code class="language-plaintext highlighter-rouge">UnpoolWithSkip</code> est le pendant de <code class="language-plaintext highlighter-rouge">GridPool</code> dans le décodeur, permettant de remonter en résolution tout en fusionnant l’information multi-échelle via les skip connections.</p> <figure> <picture> <img src="/assets/img/poinTransformerv2/unpoolWithSkip.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="problème-avec-k-nn-interpolation-ptv1">Problème avec K-NN Interpolation (PTv1)</h2> <h3 id="algorithme-dinterpolation-ptv1">Algorithme d’Interpolation PTv1</h3> <p>Dans PTv1, pour passer de M points (basse résolution) à N points (haute résolution), on utilise une <strong>interpolation par K-NN</strong> :</p> <h3 id="problèmes-de-linterpolation">Problèmes de l’Interpolation</h3> <p><strong>1. Coût computationnel :</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Pour chaque point haute résolution N:
#   - Calculer M distances
#   - Trier pour trouver les K plus proches
#   - Calculer la moyenne pondérée
</span>
<span class="n">Complexité</span><span class="p">:</span> <span class="nc">O</span><span class="p">(</span><span class="n">N</span> <span class="err">×</span> <span class="n">M</span> <span class="n">log</span> <span class="n">M</span><span class="p">)</span>

<span class="c1"># Exemple: M=25k, N=100k
</span><span class="n">Opérations</span><span class="p">:</span> <span class="mi">100</span><span class="n">k</span> <span class="err">×</span> <span class="mi">25</span><span class="n">k</span> <span class="err">×</span> <span class="nf">log</span><span class="p">(</span><span class="mi">25</span><span class="n">k</span><span class="p">)</span> <span class="err">≈</span> <span class="mi">35</span> <span class="n">milliards</span> <span class="err">!</span>
</code></pre></div></div> <h2 id="solution--map-unpooling-ptv2">Solution : Map Unpooling (PTv2)</h2> <h3 id="principe--réutilisation-du-cluster-mapping">Principe : Réutilisation du Cluster Mapping</h3> <p>L’idée géniale de PTv2 : <strong>stocker le mapping lors du downsampling</strong> et le <strong>réutiliser lors de l’upsampling</strong> !</p> <p><strong>Rappel du GridPool :</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># GridPool retourne le cluster_inverse
</span><span class="n">coord_pooled</span><span class="p">,</span> <span class="n">feat_pooled</span><span class="p">,</span> <span class="n">offset_pooled</span><span class="p">,</span> <span class="n">cluster</span> <span class="o">=</span> <span class="nc">GridPool</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="c1"># cluster: (N,) - pour chaque point original, son voxel d'appartenance
</span><span class="n">cluster</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1">#          └──┬──┘  └─┬─┘  └────┬────┘  └──┬──┘
#          Voxel 0  Voxel 1  Voxel 2   Voxel 3
</span></code></pre></div></div> <p><strong>Map Unpooling :</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Pour remonter en résolution, simple indexing !
</span><span class="n">feat_upsampled</span> <span class="o">=</span> <span class="n">feat_pooled</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span>  <span class="c1"># (N, C)
</span>
<span class="c1"># Chaque point récupère les features de son voxel d'origine
</span></code></pre></div></div> <p><strong>C’est tout !</strong> Un simple lookup, complexité <strong>O(1)</strong> par point, donc <strong>O(N)</strong> total.</p> <hr/> <h2 id="algorithme-détaillé">Algorithme Détaillé</h2> <h3 id="inputs">Inputs</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Points actuels (basse résolution)
</span><span class="n">coord_low</span><span class="p">:</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>        <span class="c1"># Positions des voxels
</span><span class="n">feat_low</span><span class="p">:</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">in_ch</span><span class="p">)</span>     <span class="c1"># Features des voxels
</span><span class="n">offset_low</span><span class="p">:</span> <span class="p">(</span><span class="n">B</span><span class="p">,)</span>

<span class="c1"># Points skip (haute résolution - de l'encodeur)
</span><span class="n">coord_skip</span><span class="p">:</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>       <span class="c1"># Positions originales
</span><span class="n">feat_skip</span><span class="p">:</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">skip_ch</span><span class="p">)</span>  <span class="c1"># Features originales
</span><span class="n">offset_skip</span><span class="p">:</span> <span class="p">(</span><span class="n">B</span><span class="p">,)</span>

<span class="c1"># Cluster mapping (du GridPool correspondant)
</span><span class="n">cluster</span><span class="p">:</span> <span class="p">(</span><span class="n">N</span><span class="p">,)</span>            <span class="c1"># Pour chaque point, son voxel
</span></code></pre></div></div> <h3 id="étape-1--projection-des-features-basse-résolution">Étape 1 : Projection des Features Basse Résolution</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">feat_low_proj</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">feat_low</span><span class="p">)</span> <span class="err">→</span> <span class="n">BatchNorm1d</span> <span class="err">→</span> <span class="n">ReLU</span>
<span class="c1"># feat_low_proj: (M, out_ch)
</span></code></pre></div></div> <h3 id="étape-2--map-unpooling">Étape 2 : Map Unpooling</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Lookup direct via cluster
</span><span class="n">feat_mapped</span> <span class="o">=</span> <span class="n">feat_low_proj</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span>
<span class="c1"># feat_mapped: (N, out_ch)
</span></code></pre></div></div> <p>Chaque point récupère <strong>exactement</strong> les features de son voxel d’origine !</p> <h3 id="étape-3--projection-des-features-skip">Étape 3 : Projection des Features Skip</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">feat_skip_proj</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">feat_skip</span><span class="p">)</span> <span class="err">→</span> <span class="n">BatchNorm1d</span> <span class="err">→</span> <span class="n">ReLU</span>
<span class="c1"># feat_skip_proj: (N, out_ch)
</span></code></pre></div></div> <h3 id="étape-4--fusion-skip-connection">Étape 4 : Fusion Skip Connection</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">feat_fused</span> <span class="o">=</span> <span class="n">feat_mapped</span> <span class="o">+</span> <span class="n">feat_skip_proj</span>
<span class="c1"># feat_fused: (N, out_ch)
</span></code></pre></div></div> <p><strong>Visualisation :</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Basse résolution (upsampled):        Skip (haute résolution):
    feat_mapped                           feat_skip_proj
         ↓                                      ↓
    [0.2, 0.5, 0.1, 0.8]              [0.3, 0.1, 0.6, 0.2]
         ↓                                      ↓
         └──────────────── + ────────────────┘
                             ↓
                    [0.5, 0.6, 0.7, 1.0]
                         feat_fused
</code></pre></div></div> <h3 id="étape-5--output">Étape 5 : Output</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="p">[</span><span class="n">coord_skip</span><span class="p">,</span> <span class="n">feat_fused</span><span class="p">,</span> <span class="n">offset_skip</span><span class="p">]</span>
<span class="c1"># On retourne les coordonnées skip (haute résolution)
# Avec les features fusionnées
</span></code></pre></div></div> <hr/> <h2 id="encoder-et-decoder--vue-complète">Encoder et Decoder : Vue Complète</h2> <h3 id="encoder">Encoder</h3> <figure> <picture> <img src="/assets/img/poinTransformerv2/encoder.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Encoder</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># Downsampling + enrichissement features
</span>        <span class="n">points_pooled</span><span class="p">,</span> <span class="n">cluster</span> <span class="o">=</span> <span class="nc">GridPool</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        
        <span class="c1"># Attention locale sur les voxels
</span>        <span class="n">points_out</span> <span class="o">=</span> <span class="nc">BlockSequence</span><span class="p">(</span><span class="n">points_pooled</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">points_out</span><span class="p">,</span> <span class="n">cluster</span>
</code></pre></div></div> <h3 id="decoder">Decoder</h3> <figure> <picture> <img src="/assets/img/poinTransformerv2/decoder.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Decoder</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">points_low</span><span class="p">,</span> <span class="n">points_skip</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
        <span class="c1"># Upsampling + fusion skip
</span>        <span class="n">points_up</span> <span class="o">=</span> <span class="nc">UnpoolWithSkip</span><span class="p">(</span><span class="n">points_low</span><span class="p">,</span> <span class="n">points_skip</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
        
        <span class="c1"># Attention locale sur les points upsampled
</span>        <span class="n">points_out</span> <span class="o">=</span> <span class="nc">BlockSequence</span><span class="p">(</span><span class="n">points_up</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">points_out</span>
</code></pre></div></div> <hr/> <h2 id="performance-globale--ptv1-vs-ptv2">Performance Globale : PTv1 vs PTv2</h2> <h3 id="mémoire">Mémoire</h3> <figure> <picture> <img src="/assets/img/poinTransformerv2/ptv2_time_diff.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="précision">Précision</h3> <figure> <picture> <img src="/assets/img/poinTransformerv2/ptv2_s3dis_miou.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/>]]></content><author><name></name></author><category term="computer-vision"/><category term="deep-learning"/><category term="point-cloud"/><category term="transformer"/><category term="architecture"/><summary type="html"><![CDATA[Detailed analysis of the Point Transformer v2 architecture for point-cloud segmentation and classification]]></summary></entry><entry><title type="html">Point Transformer v1: Architecture and Implementation Details</title><link href="http://antoineach.github.io//blog/2025/pointTransformerV1/" rel="alternate" type="text/html" title="Point Transformer v1: Architecture and Implementation Details"/><published>2025-10-13T00:00:00+00:00</published><updated>2025-10-13T00:00:00+00:00</updated><id>http://antoineach.github.io//blog/2025/pointTransformerV1</id><content type="html" xml:base="http://antoineach.github.io//blog/2025/pointTransformerV1/"><![CDATA[<h1 id="point-transformer-v1-architecture-and-implementation-details">Point Transformer v1: Architecture and Implementation Details</h1> <h2 id="introduction">Introduction</h2> <p><strong>Point Transformer v1</strong> is a model for segmentation and classification of 3D point clouds that adapts the Transformer mechanism to unstructured 3D data while respecting point-cloud specific constraints. Published in 2021, it adapts attention to local neighborhoods and the irregular nature of point clouds.</p> <p>The model follows a <strong>U-Net</strong>-like architecture composed of three main layer types:</p> <ul> <li><strong>PointTransformerLayer</strong>: local attention over the K nearest neighbors</li> <li><strong>TransitionDown</strong>: spatial downsampling using Furthest Point Sampling (FPS)</li> <li><strong>TransitionUp</strong>: upsampling with skip connections</li> </ul> <hr/> <h2 id="overall-architecture">Overall Architecture</h2> <p>The network follows an encoder–decoder (U-Net) design:</p> <figure> <picture> <img src="/assets/img/pointTransformerv1/pointTransformerV1_architecture.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Key features:</strong></p> <ul> <li><strong>Local attention</strong>: attention is computed only over K nearest neighbors (typically K = 16) rather than globally.</li> <li><strong>Permutation invariance</strong>: the architecture respects the lack of natural ordering in point clouds.</li> <li><strong>Skip connections</strong>: U-Net style skip connections preserve spatial details.</li> </ul> <hr/> <h3 id="-input-reminder--batched-point-clouds">🧱 Input Reminder — Batched Point Clouds</h3> <p>Before diving into PointTransformer internals, recall that we handle <strong>batches of point clouds</strong> by concatenating them into a single tensor:</p> \[X \in \mathbb{R}^{N \times C}, \quad \text{where } N = N_1 + N_2 + \dots + N_B\] <p>and we keep <strong>offsets</strong> to delimit each cloud’s boundaries: \(\text{offsets} = [N_1,, N_1{+}N_2,, \dots,, N_1{+}N_2{+}\dots{+}N_B]\)</p> <p>Each row of (X) corresponds to one 3D point and its features — so linear layers act point-wise, without mixing points from different objects.</p> <p>For a detailed explanation of this batching strategy, see 👉 <a href="/blog/2025/batchingPointclouds/">Batching Point Clouds</a>.</p> <hr/> <h2 id="pointtransformerblock-residual-block">PointTransformerBlock: Residual Block</h2> <p><code class="language-plaintext highlighter-rouge">PointTransformerBlock</code> wraps the <code class="language-plaintext highlighter-rouge">PointTransformerLayer</code> inside a residual block (ResNet-style).</p> <figure> <picture> <img src="/assets/img/pointTransformerv1/pointTransformerBlock.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Residual connections improve gradient flow, help learn residual mappings, and preserve initial information.</p> <hr/> <h2 id="pointtransformerlayer-vectorial-local-attention">PointTransformerLayer: Vectorial Local Attention</h2> <h3 id="overview">Overview</h3> <p>The <code class="language-plaintext highlighter-rouge">PointTransformerLayer</code> implements a <strong>local vector attention</strong> mechanism inspired by Transformers, but adapted to point clouds.</p> <figure> <picture> <img src="/assets/img/pointTransformerv1/pointTransformerLayer.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="why-use-q---k-instead-of-qkᵀ">Why use Q - K instead of Q·Kᵀ?</h3> <p>The batching constraint is central here. In standard Transformers you compute:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attention_scores</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">@</span> <span class="n">K</span><span class="p">.</span><span class="n">T</span>  <span class="c1"># shape (N, N) -&gt; global attention
</span></code></pre></div></div> <p>But with concatenated point clouds:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>points = [ pc1_points | pc2_points | pc3_points ]
          ←    N_1   → ←    N_2   → ←    N_3   →
</code></pre></div></div> <p>A full \(N \times N\) attention matrix would include cross-cloud scores (e.g. between pc1 and pc2), which is <strong>invalid</strong>.</p> <p>Point Transformer avoids this by:</p> <ol> <li><strong>Local attention only</strong>: compute attention over the K nearest neighbors within the same cloud.</li> <li><strong>Neighbor search respecting offsets</strong>: <code class="language-plaintext highlighter-rouge">query_and_group</code> or neighbor routines use offsets to restrict neighbor search to the same cloud.</li> <li><strong>Using Q − K (relative vector) rather than a global dot product</strong>:</li> </ol> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># For each query point, consider its K neighbors (guaranteed same cloud)
</span><span class="n">attention_input</span> <span class="o">=</span> <span class="n">key_neighbors</span> <span class="o">-</span> <span class="n">query_expanded</span>  <span class="c1"># shape (N, K, out_dim)
# A vector difference rather than a scalar product
</span></code></pre></div></div> <p>This vector difference captures relative relationships without producing a full N×N matrix and without creating invalid cross-cloud attention.</p> <h3 id="position-encoding">Position encoding</h3> <p>Positions are explicitly encoded and added to the attention input:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">relative_positions</span> <span class="o">=</span> <span class="n">neighbor_positions</span> <span class="o">-</span> <span class="n">query_position</span>  <span class="c1"># (N, K, 3)
</span><span class="n">encoded_positions</span> <span class="o">=</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">relative_positions</span><span class="p">)</span>              <span class="c1"># (N, K, out_dim)
</span><span class="n">attention_input</span> <span class="o">=</span> <span class="p">(</span><span class="n">Q</span> <span class="o">-</span> <span class="n">K</span><span class="p">)</span> <span class="o">+</span> <span class="n">encoded_positions</span>
</code></pre></div></div> <h3 id="vectorial-attention-with-groups">Vectorial attention with groups</h3> <p>Instead of a single scalar weight per neighbor, Point Transformer produces <strong><code class="language-plaintext highlighter-rouge">num_groups</code> weights per neighbor</strong>. Let’s understand why and how this works.</p> <h4 id="visual-diagram">Visual Diagram</h4> <p>Here’s what happens for <strong>one point</strong> with <strong>K=3 neighbors</strong> and <strong>num_groups=4, out_dim=16</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Each neighbor's value vector (16 dims):
┌─────┬─────┬─────┬─────┐
│ G0  │ G1  │ G2  │ G3  │  ← 4 groups of 4 dimensions
│ [4] │ [4] │ [4] │ [4] │
└─────┴─────┴─────┴─────┘

Attention weights for each neighbor (4 weights):
Neighbor 1: [w₁⁽⁰⁾, w₁⁽¹⁾, w₁⁽²⁾, w₁⁽³⁾]
Neighbor 2: [w₂⁽⁰⁾, w₂⁽¹⁾, w₂⁽²⁾, w₂⁽³⁾]
Neighbor 3: [w₃⁽⁰⁾, w₃⁽¹⁾, w₃⁽²⁾, w₃⁽³⁾]

Weighted multiplication:
            ┌─────────────────────────────────┐
Neighbor 1: │w₁⁽⁰⁾·G0│w₁⁽¹⁾·G1│w₁⁽²⁾·G2│w₁⁽³⁾·G3│
            ├─────────────────────────────────┤
Neighbor 2: │w₂⁽⁰⁾·G0│w₂⁽¹⁾·G1│w₂⁽²⁾·G2│w₂⁽³⁾·G3│
            ├─────────────────────────────────┤
Neighbor 3: │w₃⁽⁰⁾·G0│w₃⁽¹⁾·G1│w₃⁽²⁾·G2│w₃⁽³⁾·G3│
            └─────────────────────────────────┘
                        ↓ sum over neighbors
            ┌─────────────────────────────────┐
Output:     │  G0   │  G1   │  G2   │  G3   │  (16 dims)
            └─────────────────────────────────┘
</code></pre></div></div> <p>The shape <code class="language-plaintext highlighter-rouge">(N, K, num_groups, dim_per_group)</code> represents:</p> <ul> <li>For each of N points</li> <li>For each of K neighbors</li> <li>We have num_groups separate feature groups</li> <li>Each group has dim_per_group dimensions</li> </ul> <p>And each group gets its own attention weight, allowing fine-grained control over feature aggregation.</p> <p>For example a group may focus on</p> <ul> <li>Dimensions 0-15: color information</li> <li>Dimensions 16-31: geometric properties</li> <li>Dimensions 32-47: texture features</li> <li>Dimensions 48-63: semantic context</li> </ul> <hr/> <h2 id="transitiondown-spatial-downsampling">TransitionDown: Spatial Downsampling</h2> <p><code class="language-plaintext highlighter-rouge">TransitionDown</code> reduces the number of points (analogous to strided conv).</p> <figure> <picture> <img src="/assets/img/pointTransformerv1/transitionDown_stride!=1.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Pipeline (high-level):</p> <ol> <li><strong>Compute new counts</strong>: for each cloud, new_count = old_count // stride.</li> <li><strong>Farthest Point Sampling (FPS)</strong>: choose M ≈ N/stride representative points that maximize minimal distance; ensures spatial coverage.</li> <li><strong>K-NN grouping</strong>: for each sampled point, gather its K neighbors in the original cloud (with relative positions if <code class="language-plaintext highlighter-rouge">use_xyz=True</code>). Result: <code class="language-plaintext highlighter-rouge">(M, K, 3 + in_dim)</code>.</li> <li><strong>Projection + normalization</strong>: linear on neighbor features, BatchNorm + ReLU → <code class="language-plaintext highlighter-rouge">(M, out_dim, K)</code>.</li> <li><strong>MaxPooling</strong>: aggregate K neighbors by channel-wise max → <code class="language-plaintext highlighter-rouge">(M, out_dim)</code>.</li> </ol> <p>Result: reduce N points to M points (M ≈ N/stride) with locally aggregated features.</p> <figure> <picture> <img src="/assets/img/pointTransformerv1/fps_knn.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h2 id="transitionup-upsampling-with-skip-connections">TransitionUp: Upsampling with Skip Connections</h2> <p><code class="language-plaintext highlighter-rouge">TransitionUp</code> increases resolution and fuses multi-scale information.</p> <figure> <picture> <img src="/assets/img/pointTransformerv1/transitionUp_with_pxoo.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Explanation:</strong></p> <p>The interpolation transfers features from M source points to N target points (typically M &lt; N for upsampling).</p> <figure> <picture> <img src="/assets/img/pointTransformerv1/interpolation.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Algorithm:</strong></p> <ol> <li><strong>K-NN</strong>: For each target point, find its K=3 nearest neighbors in the source cloud</li> <li><strong>Weights</strong>: Compute normalized inverse distance weights: points closer to the target have higher weights</li> <li><strong>Interpolation</strong>: Weighted average of the K neighbor features</li> </ol> <p><strong>Code:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">interpolation</span><span class="p">(</span><span class="n">p_source</span><span class="p">,</span> <span class="n">p_target</span><span class="p">,</span> <span class="n">x_source</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Args:
        p_source: (M, 3) - source positions
        p_target: (N, 3) - target positions  
        x_source: (M, C) - source features
    Returns:
        output: (N, C) - interpolated features
    </span><span class="sh">"""</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">p_target</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_source</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="c1"># Find K nearest neighbors
</span>        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">p_source</span> <span class="o">-</span> <span class="n">p_target</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">k_nearest</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">)[:</span><span class="n">K</span><span class="p">]</span>
        
        <span class="c1"># Inverse distance weighting
</span>        <span class="n">dists</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">k_nearest</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dists</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">/=</span> <span class="n">weights</span><span class="p">.</span><span class="nf">sum</span><span class="p">()</span>  <span class="c1"># normalize
</span>        
        <span class="c1"># Weighted average
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="n">output</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_source</span><span class="p">[</span><span class="n">k_nearest</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div> <p><strong>Formula:</strong> \(\text{output}[n] = \sum_{i=0}^{K-1} w_i \cdot \text{x}_\text{source}[\text{neighbor}_i], \quad w_i = \frac{1/d_i}{\sum_j 1/d_j}\)</p> <h2 id="references">References</h2> <ul> <li>Point Transformer paper (ICCV 2021): <a href="https://arxiv.org/abs/2012.09164">https://arxiv.org/abs/2012.09164</a></li> <li>Official code: <a href="https://github.com/POSTECH-CVLab/point-transformer">https://github.com/POSTECH-CVLab/point-transformer</a></li> <li>See also my post on <a href="/blog/2025/batchingPointclouds/">Batching of Point Clouds</a></li> </ul>]]></content><author><name></name></author><category term="computer-vision"/><category term="deep-learning"/><category term="point-cloud"/><category term="transformer"/><category term="architecture"/><summary type="html"><![CDATA[Detailed analysis of the Point Transformer v1 architecture for point-cloud segmentation and classification]]></summary></entry><entry><title type="html">Batching PointClouds</title><link href="http://antoineach.github.io//blog/2025/batchingPointclouds/" rel="alternate" type="text/html" title="Batching PointClouds"/><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>http://antoineach.github.io//blog/2025/batchingPointclouds</id><content type="html" xml:base="http://antoineach.github.io//blog/2025/batchingPointclouds/"><![CDATA[<h2 id="️-characteristics-of-point-clouds">☁️ Characteristics of Point Clouds</h2> <ol> <li><strong>Variable size</strong> – each point cloud contains a different number of points \(N\).</li> <li><strong>Unordered</strong> – permuting the points does not change the represented object.</li> <li><strong>Irregular</strong> – there is no fixed neighborhood structure like in images.</li> <li><strong>Continuous</strong> – each point lives in continuous 3D space:<br/> \((x, y, z) \in \mathbb{R}^3\)</li> </ol> <hr/> <h2 id="️-the-variable-number-of-points-problem">⚠️ The Variable Number of Points Problem</h2> <p>The fact that each point cloud has a different number of points \(N\) prevents <strong>batch parallelization</strong> like in image-based neural networks.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Classic computer vision: easy batching
</span><span class="n">images</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">224</span><span class="p">)</span>
<span class="c1"># ✅ All images have the same shape → can be stacked together
</span>
<span class="c1"># With point clouds — impossible!
</span><span class="n">obj1</span> <span class="o">=</span> <span class="mi">1523</span> <span class="n">points</span>   <span class="c1"># chair
</span><span class="n">obj2</span> <span class="o">=</span> <span class="mi">3891</span> <span class="n">points</span>   <span class="c1"># table
</span><span class="n">obj3</span> <span class="o">=</span> <span class="mi">892</span> <span class="n">points</span>    <span class="c1"># lamp
</span>
<span class="n">batch</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">obj3</span><span class="p">])</span>  <span class="c1"># ❌ Different sizes → error!
</span></code></pre></div></div> <hr/> <h2 id="-common-strategies-to-handle-variable-point-counts">🧩 Common Strategies to Handle Variable Point Counts</h2> <h3 id="1️⃣-batch-size--1">1️⃣ Batch Size = 1</h3> <p>Process each object individually. → <strong>Drawback:</strong> training is extremely slow, and statistical relations between samples in a batch are lost.</p> <hr/> <h3 id="2️⃣-downsampling">2️⃣ <strong>Downsampling</strong></h3> <p>Randomly sample each point cloud to reach a fixed size (e.g. 1024 points). → <strong>Pros:</strong> Simple to implement → <strong>Cons:</strong> Loss of geometric detail, especially when point counts differ greatly (e.g. from 1k to 10k → 90% data loss).</p> <hr/> <h3 id="3️⃣-oversampling">3️⃣ <strong>Oversampling</strong></h3> <p>Duplicate some points to reach the target size ( \(N' = N + \Delta N\) ). This works for architectures like <strong>PointNet</strong>, since each point is independently projected via a shared MLP, then aggregated with <strong>max pooling</strong>.</p> <div class="row justify-content-center"> <div class="col-md-8 text-center"> <figure> <picture> <img src="/assets/img/maxpool.png" class="img-fluid rounded z-depth-1 shadow-sm" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption mt-2 text-muted">Example of PointNet using shared MLP + max pooling.</div> </div> </div> <p>However, if we replaced max pooling with <strong>mean pooling</strong>, duplicates would bias the average and distort the representation.</p> <hr/> <h3 id="4️⃣-sparse-tensor-representation-practical-solution">4️⃣ <strong>Sparse Tensor Representation (Practical Solution)</strong></h3> <p>In practice, frameworks like <strong>Torch Scatter</strong> allow concatenation of all points from a batch while preserving object boundaries.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Instead of stacking → concatenate all points
</span><span class="n">p</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">obj1_points</span><span class="p">,</span> <span class="n">obj2_points</span><span class="p">,</span> <span class="n">obj3_points</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># [6306, 3]  (x, y, z)
</span><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">obj1_features</span><span class="p">,</span> <span class="n">obj2_features</span><span class="p">,</span> <span class="n">obj3_features</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># [6306, 64]  (features)
</span>
<span class="c1"># Track where each object ends using offsets
</span><span class="n">o</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="mi">1523</span><span class="p">,</span> <span class="mi">5414</span><span class="p">,</span> <span class="mi">6306</span><span class="p">])</span>  <span class="c1"># cumulative end indices
</span></code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|----------obj1----------|---------------obj2--------------|---obj3---|
0                       1523                             5414        6306
                         ↑                                 ↑          ↑
                      offset[0]                       offset[1]  offset[2]
</code></pre></div></div> <p>These <strong>offsets</strong> let the model know where each object starts and ends in the concatenated tensor.</p> <div class="row justify-content-center"> <div class="col-md-8 text-center"> <figure> <picture> <img src="/assets/img/torch_scatter.svg" class="img-fluid rounded z-depth-1 shadow-sm" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption mt-2 text-muted">Example of Torch Scatter add operator.</div> </div> </div> <hr/> <h1 id="other-operator-that-supports-the-concatenation-of-pointclouds--nnlinear">Other operator that supports the concatenation of pointclouds : nn.Linear</h1> <h2 id="definition">Definition</h2> <p>The <code class="language-plaintext highlighter-rouge">torch.nn.Linear</code> layer applies an affine linear transformation:</p> \[y = xA^T + b\] <p>Where:</p> <ul> <li>\(x \in \mathbb{R}^{n \times d_{in}}\) is the input matrix (n samples, \(d_{in}\) input features)</li> <li>\(A \in \mathbb{R}^{d_{out} \times d_{in}}\) is the weight matrix</li> <li>\(b \in \mathbb{R}^{d_{out}}\) is the bias vector</li> <li>\(y \in \mathbb{R}^{n \times d_{out}}\) is the output matrix</li> </ul> <p>The bias \(b\) is broadcast and added to each row of \(xA^T\).</p> <h2 id="application-to-concatenated-point-clouds">Application to Concatenated Point Clouds</h2> <h3 id="setup">Setup</h3> <p>Consider two point clouds with different numbers of points:</p> <ul> <li>Point cloud 1: $N_1 = 2$ points</li> <li>Point cloud 2: $N_2 = 3$ points</li> <li>Each point has 3 coordinates (x, y, z)</li> </ul> <p><strong>Point Cloud 1:</strong> \(X_1 = \begin{bmatrix} x_{11} &amp; x_{12} &amp; x_{13} \\ x_{21} &amp; x_{22} &amp; x_{23} \end{bmatrix} \in \mathbb{R}^{2 \times 3}\)</p> <p><strong>Point Cloud 2:</strong> \(X_2 = \begin{bmatrix} x_{31} &amp; x_{32} &amp; x_{33} \\ x_{41} &amp; x_{42} &amp; x_{43} \\ x_{51} &amp; x_{52} &amp; x_{53} \end{bmatrix} \in \mathbb{R}^{3 \times 3}\)</p> <h3 id="concatenation">Concatenation</h3> <p>Concatenate along the point dimension:</p> \[X = \begin{bmatrix} X_1 \\ X_2 \end{bmatrix} = \begin{bmatrix} x_{11} &amp; x_{12} &amp; x_{13} \\ x_{21} &amp; x_{22} &amp; x_{23} \\ x_{31} &amp; x_{32} &amp; x_{33} \\ x_{41} &amp; x_{42} &amp; x_{43} \\ x_{51} &amp; x_{52} &amp; x_{53} \end{bmatrix} \in \mathbb{R}^{5 \times 3}\] <h3 id="linear-transformation">Linear Transformation</h3> <p>Apply <code class="language-plaintext highlighter-rouge">nn.Linear(in_features=3, out_features=2)</code>:</p> <p><strong>Weight matrix:</strong> \(A = \begin{bmatrix} w_{11} &amp; w_{12} &amp; w_{13} \\ w_{21} &amp; w_{22} &amp; w_{23} \end{bmatrix} \in \mathbb{R}^{2 \times 3}\)</p> <p><strong>Bias vector:</strong> \(b = \begin{bmatrix} b_1 \\ b_2 \end{bmatrix} \in \mathbb{R}^{2}\)</p> <p><strong>Transpose of weight matrix:</strong> \(A^T = \begin{bmatrix} w_{11} &amp; w_{21} \\ w_{12} &amp; w_{22} \\ w_{13} &amp; w_{23} \end{bmatrix} \in \mathbb{R}^{3 \times 2}\)</p> <h3 id="matrix-multiplication-y--xat--b">Matrix Multiplication: $Y = XA^T + b$</h3> \[Y = \begin{bmatrix} x_{11} &amp; x_{12} &amp; x_{13} \\ x_{21} &amp; x_{22} &amp; x_{23} \\ x_{31} &amp; x_{32} &amp; x_{33} \\ x_{41} &amp; x_{42} &amp; x_{43} \\ x_{51} &amp; x_{52} &amp; x_{53} \end{bmatrix} \begin{bmatrix} w_{11} &amp; w_{21} \\ w_{12} &amp; w_{22} \\ w_{13} &amp; w_{23} \end{bmatrix} + \begin{bmatrix} b_1 &amp; b_2 \end{bmatrix}\] <h3 id="row-by-row-computation">Row-by-Row Computation</h3> <p>Each output row is computed independently:</p> \[y_1 = \begin{bmatrix} x_{11}w_{11} + x_{12}w_{12} + x_{13}w_{13} + b_1 &amp; x_{11}w_{21} + x_{12}w_{22} + x_{13}w_{23} + b_2 \end{bmatrix}\] \[y_2 = \begin{bmatrix} x_{21}w_{11} + x_{22}w_{12} + x_{23}w_{13} + b_1 &amp; x_{21}w_{21} + x_{22}w_{22} + x_{23}w_{23} + b_2 \end{bmatrix}\] \[y_3 = \begin{bmatrix} x_{31}w_{11} + x_{32}w_{12} + x_{33}w_{13} + b_1 &amp; x_{31}w_{21} + x_{32}w_{22} + x_{33}w_{23} + b_2 \end{bmatrix}\] \[y_4 = \begin{bmatrix} x_{41}w_{11} + x_{42}w_{12} + x_{43}w_{13} + b_1 &amp; x_{41}w_{21} + x_{42}w_{22} + x_{43}w_{23} + b_2 \end{bmatrix}\] \[y_5 = \begin{bmatrix} x_{51}w_{11} + x_{52}w_{12} + x_{53}w_{13} + b_1 &amp; x_{51}w_{21} + x_{52}w_{22} + x_{53}w_{23} + b_2 \end{bmatrix}\] <h2 id="key-property-no-mixing-between-points">Key Property: No Mixing Between Points</h2> <p>Each output row $y_i$ depends <strong>only</strong> on its corresponding input row \(x_i\):</p> \[y_i = x_i A^T + b, \quad i = 1, 2, \ldots, 5\] <p>Therefore:</p> <ul> <li>Rows 1-2 (from PC1) are transformed independently</li> <li>Rows 3-5 (from PC2) are transformed independently</li> <li><strong>No information is mixed between different points or different point clouds</strong></li> </ul>]]></content><author><name></name></author><summary type="html"><![CDATA[A comprehensive explanation of Batching PointClouds.]]></summary></entry><entry><title type="html">MultiHead Attention Visualized</title><link href="http://antoineach.github.io//blog/2025/multiheadattention/" rel="alternate" type="text/html" title="MultiHead Attention Visualized"/><published>2025-10-08T00:00:00+00:00</published><updated>2025-10-08T00:00:00+00:00</updated><id>http://antoineach.github.io//blog/2025/multiheadattention</id><content type="html" xml:base="http://antoineach.github.io//blog/2025/multiheadattention/"><![CDATA[<p>This post is adapted from <a href="https://www.geeksforgeeks.org/nlp/multi-head-attention-mechanism/">GeeksforGeeks</a>’s article on the Multi-Head Attention Mechanism by <em>sanjulika_sharma</em>.<br/> It provides an intuitive understanding of how multiple attention heads work in parallel to capture different representation subspaces.</p> <hr/> <h2 id="-what-is-multi-head-attention">🧠 What is Multi-Head Attention?</h2> <p>The Multi-Head Attention mechanism allows a model to <strong>focus on different parts of a sequence simultaneously</strong>.<br/> Each head learns different contextual relationships — for example, one might focus on word order while another captures long-range dependencies.</p> <hr/> <h2 id="-visualization">📊 Visualization</h2> <p>Below is a simple diagram illustrating how queries (Q), keys (K), and values (V) interact across multiple heads.</p> <div class="row justify-content-center mt-4"> <div class="col-md-8 text-center"> <figure> <picture> <img src="/assets/img/multiheadAttention.svg" class="img-fluid rounded z-depth-1 shadow-sm" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption mt-2 text-muted"> Multi-Head Attention — each head performs scaled dot-product attention in parallel. </div> </div> </div> <hr/> <h2 id="️-implementation-example">⚙️ Implementation Example</h2> <p>Below is a PyTorch implementation of <strong>Multi-Head Attention</strong>.<br/> It combines several attention heads computed in parallel, each with its own query, key, and value subspace.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MultiheadAttention</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">in_dim</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">in_dim</span> <span class="o">=</span> <span class="n">in_dim</span>      <span class="c1"># Input embedding size
</span>        <span class="n">self</span><span class="p">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">D</span>                <span class="c1"># Model embedding size
</span>        <span class="n">self</span><span class="p">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span>                <span class="c1"># Number of attention heads
</span>
        <span class="c1"># Compute Q, K, V for all heads at once
</span>        <span class="n">self</span><span class="p">.</span><span class="n">qkv_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">in_dim</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span>
        <span class="c1"># Final projection layer
</span>        <span class="n">self</span><span class="p">.</span><span class="n">linear_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">in_dim</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span>

        <span class="c1"># 1️⃣ Compute concatenated Q, K, V
</span>        <span class="n">qkv</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">qkv_layer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># (B, N, 3*D)
</span>
        <span class="c1"># 2️⃣ Split heads
</span>        <span class="n">qkv</span> <span class="o">=</span> <span class="n">qkv</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">H</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">D</span> <span class="o">//</span> <span class="n">self</span><span class="p">.</span><span class="n">H</span><span class="p">)</span>
        <span class="n">qkv</span> <span class="o">=</span> <span class="n">qkv</span><span class="p">.</span><span class="nf">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">qkv</span><span class="p">.</span><span class="nf">chunk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Each: (B, H, N, D//H)
</span>
        <span class="c1"># 3️⃣ Scaled dot-product attention
</span>        <span class="n">d_k</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">scaled</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">d_k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">scaled</span> <span class="o">+=</span> <span class="n">mask</span>
        <span class="n">attention</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">softmax</span><span class="p">(</span><span class="n">scaled</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># 4️⃣ Apply attention to values
</span>        <span class="n">values</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">attention</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># 5️⃣ Concatenate heads
</span>        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">D</span><span class="p">)</span>

        <span class="c1"># 6️⃣ Final linear projection
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">linear_layer</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</code></pre></div></div> <hr/> <h2 id="-key-takeaway">🧩 Key Takeaway</h2> <blockquote> <p>Multi-Head Attention enhances a model’s representational capacity by letting it attend to information from <strong>different representation subspaces</strong> simultaneously — leading to richer contextual understanding.</p> </blockquote> <hr/>]]></content><author><name></name></author><summary type="html"><![CDATA[A comprehensive explanation of MultiHead Attention with dimensions.]]></summary></entry></feed>